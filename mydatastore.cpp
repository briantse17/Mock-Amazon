#include "mydatastore.h"#include "msort.h"#include "heap.h"using namespace std;struct compRate {  bool operator()(Product* a, Product* b)  {   if(a->avgRating() > b->avgRating())    {        return true;    }    else     {        return false;    }  }};struct compName {  bool operator()(Product* a, Product* b)  {   if(a->getName() < b->getName())    {        return true;    }    else     {        return false;    }  }};myDataStore::myDataStore(){}myDataStore::~myDataStore(){		for(int i = 0; i < int(allusers.size()); i++)	{		//deallocate memory on heap for user objects		delete allusers[i];	}	for(int j = 0; j < int(allproducts.size()); j++)	{		//need to deallocate memory on heap created for products		delete allproducts[j];	}}void myDataStore::addProduct(Product* p){	//call specific keyword function for each product type	set<string> keys = p->keywords();	typename set<string>:: iterator it = keys.begin();	while(it!=keys.end())	{		//if we do not find the right keyword in the map		if(pmap.find(*it) == pmap.end())		{			//create a new set of Product* containing this keyword			set<Product*> productSet; 			//add this specific product into the set			productSet.insert(p);			//create a key value pair with key being keyword and value being the set			pmap.insert(make_pair(*it, productSet));		}		else		{			//add to the set of Product* already created with respective keyword			pmap.find(*it)->second.insert(p);		}		it++;	}	//add this product into vector containing pointers to all products for delete later	allproducts.push_back(p);}void myDataStore::addUser(User* u){	//create a vector of Product* to represent a user's specific cart	vector<Product*> cart;	umap.insert(make_pair(u,cart));	//add this user to a vector holding pointers to all users created for delete later	allusers.push_back(u);}vector<Product*> myDataStore::search(vector<string>& terms, int type, string check){	vector<Product*> temp;	typename vector<string>:: iterator it = terms.begin();	set<Product*> hits;	bool first = true;	while(it!=terms.end())	{		//if we find the right keyword in our keyword,Product* map		if(pmap.find(*it) != pmap.end())		{			//check if it's an AND search			if(type == 0)			{				//check to see if it's first iteration to eheck edge case for setIntersection				if(first)				{					//initalize hits set to the product* set in map so we don't compare an empty set					hits = pmap.find(*it)->second;					hits = setIntersection(hits, pmap.find(*it)->second);					//update bool variable to indicate we're not in first iteration any more					first = false;				}				else				{					hits = setIntersection(hits, pmap.find(*it)->second);				}			}			//if it's an OR search			else if (type == 1)			{				hits = setUnion(hits, pmap.find(*it)->second);			}		}		it++;	} 	//push all product* from set to vector	typename set<Product*>:: iterator its = hits.begin();	while(its!=hits.end())	{		temp.push_back(*its);		its++;	}	if(check == "r")	{		compRate c;		mergeSort(temp, c);	}	else if(check == "n")	{		compName c2;		mergeSort(temp, c2);	}	return temp;}void myDataStore::dump(std::ostream& ofile){	ofile << "<products>" << endl;	for(int i = 0; i < int(allproducts.size()); i++)	{		allproducts[i]->dump(ofile);	}	ofile <<"</products>" << endl;	ofile << "<users>" << endl;	for(int j = 0; j < int(allusers.size()); j++)	{		allusers[j]->dump(ofile);	}	ofile << "</users>" << endl;	ofile << "<reviews>" << endl;	for(int k = 0; k < int(allproducts.size()); k++)	{		allproducts[k]->dumpRev(ofile);	}	ofile << "</reviews>" << endl;}void myDataStore::addCart(string username, Product* p){	//use this to check if we found the right user	bool done = false;	map<User*, vector<Product*>>::iterator it;	for(it = umap.begin(); it != umap.end(); ++it)   	{		//found the matching user		if(it->first->getName() == username)		{			//add product to user's cart			it->second.push_back(p);			done = true;			break;		}	}	//if done == false, we did not find a matching user	if (done == false)	{		cout << "Invalid request" << endl;	}}void myDataStore::viewCart(string username){	//bool to check if we found matching user	bool found = false;	map<User*, vector<Product*>>::iterator it;	for(it = umap.begin(); it != umap.end(); ++it)   	{		if(it->first->getName() == username)		{			for(unsigned int i = 1; i <= it->second.size(); i++)			{				cout << "Item " << i << endl;				cout << it->second[i-1]->displayString() << endl;				cout << endl;			}			found = true;			break;		}	}	if (found == false)	{		cout << "Invalid username" << endl;	}}void myDataStore::buyCart(string username){	//to check if matching user found	bool found = false;	map<User*, vector<Product*>>::iterator it;	vector<Product*> ncart;	for(it = umap.begin(); it != umap.end(); ++it)   	{		if(it->first->getName() == username)		{			int size = it->second.size();			for(int i = 0; i < size; i++)			{				//check if user has enough money or item still in stock				if(it->second[i]->getQty() != 0 && it->first->getBalance() - it->second[i]->getPrice() >= 0)				{					it->second[i]->subtractQty(1); 					it->first->deductAmount(it->second[i]->getPrice());				}				//if user can't buy item for above reasons, push product into new vector 				else				{					ncart.push_back(it->second[i]);				}			}			found = true;			//update user's cart with new vector of products containing products they couldn't buy			it->second = ncart;			break;		}	}	if (found == false)	{		cout << "Invalid username" << endl;	}}void myDataStore::addReview(const std::string& prodName,			   int rating,			   const std::string& username,			   const std::string& date,			   const std::string& review_text){	int day;	int month;	string day_;	string month_;	string year_;	stringstream ss(date);	getline(ss, year_, '-');	getline(ss, month_, '-');	getline(ss, day_);	if(int(day_.size()) != 2 || int(month_.size()) != 2 || int(year_.size()) != 4)	{		cout << "Invalid date" << endl;		return;	}	day = stoi(day_);	month = stoi(month_);	//check if month entered is greater than 0 and less than 13	if(!(month > 0) || !(month < 13))	{		cout <<"Invalid date" << endl;		return;	}	if(month == 2)	{		if(day > 28 || day < 0)		{			cout << "Invalid date" << endl;			return;		}	}	else if (month == 4 || month == 6 || month == 9 || month == 11)	{		if (day > 30 || day < 0)		{			cout << "Invalid date" << endl;			return;		}	}	else	{		if (day > 31 || day < 0)		{			cout << "Invalid date" << endl;			return;		}	}	for(int i = 0; i < int(allproducts.size()); i++)	{		if (convToLower(allproducts[i]->getName()) == convToLower(prodName))		{			allproducts[i]->addRev(rating, username, date, review_text);			for(int j = 0; j < int(allusers.size());j++)			{				if(allusers[j]->getName() == username)				{					allusers[j]->addUserRev(allproducts[i]->getName(), rating);					allusers[j]->addUserProd(allproducts[i]->getName());					break;				}			}			break;		}	}}void myDataStore::viewReview(Product* product, string username){	product->getRev(username);}bool cmp(const pair<string, double> &a, const pair<string, double> &b){	if(a.second > b.second)	{		return true;	}	else if (a.second < b.second)	{		return false;	}	else	{		return (a.first.size() < b.first.size());	}}vector<pair<string, double> > myDataStore::makeSuggestion(string currentUser){	basicSims();	vector<pair<string,double>> refined = refinedSims(currentUser);		//final vector holding user's recommendations	vector<pair<string, double>> suggestions;	int index = 0;	//find user's index in alluser vector as well as check to see if they've reviewed all products	for(int i = 0; i < int(allusers.size()); i++)	{		if(allusers[i]->getName() == currentUser)		{			index = i;			if(allusers[i]->getUserProd().size() == allproducts.size())			{				return suggestions;			}			else			{				break;			}		}	}	//store all the products that the user has not rated	set<Product*> recProds;	//store the products that the user has already rated	set<string> currProds = allusers[index]->getUserProd();	for(int i = 0; i < int(allproducts.size()); i++)	{		if(currProds.find(allproducts[i]->getName()) == currProds.end())		{			recProds.insert(allproducts[i]);		}	}	for(set<Product*>::iterator its = recProds.begin(); its != recProds.end(); ++its)	{		vector<Review> productRevs = (*its)->getReview();		//check if this product has any reviews		if(!productRevs.empty())		{			double R = 0.0;			double W = 0.0;			for(int i = 0; i < int(productRevs.size()); i++)			{				double similarity;				for(int j = 0; j < int(refined.size()); j++)				{					if(refined[j].first == productRevs[i].username)					{						similarity = refined[j].second;					}				}				R += double((1.0-similarity)*productRevs[i].rating);				W += double((1.0-similarity));			}			if(W == 0)			{				suggestions.push_back(make_pair((*its)->getName(), 0.0));			}			else			{				suggestions.push_back(make_pair((*its)->getName(), double(R/W)));			}		}	}	std::stable_sort(suggestions.begin(), suggestions.end(), cmp);	std::cout << currentUser << std::endl;	ofstream myfile ("rec.txt");	myfile << currentUser << std::endl;	//cout to terminal as well as write to rec.txt	for(int i = 0; i < int(suggestions.size()); i++)	{		std::cout << std::fixed << std::showpoint;    	std::cout << std::setprecision(2);		cout << suggestions[i].second << "  " << suggestions[i].first << endl;		myfile << std::fixed << std::showpoint;    	myfile << std::setprecision(2);		myfile << suggestions[i].second << "  " << suggestions[i].first << endl;	}	myfile.close();	return suggestions;}void myDataStore::basicSims(){	allsims = {};	for(int i = 0; i < int(allusers.size()); i++)	{		vector<pair<string, double>> temp = {};		allsims.insert(make_pair(allusers[i]->getName(),temp));		for(int j = 0; j < int(allusers.size());j++)		{			set<Product*> matches;			if(i == j)			{				continue;			}			else			{				set<Product*> set1;				set<Product*> set2;				set<string> temp1 = allusers[i]->getUserProd();				for(int k = 0; k < int(allproducts.size()); k++)				{					//if the user has reviewed the current product					if(temp1.find(allproducts[k]->getName())!= temp1.end())					{						set1.insert(allproducts[k]);					}					set<string> temp2 = allusers[j]->getUserProd();					if(temp2.find(allproducts[k]->getName())!= temp2.end())					{						set2.insert(allproducts[k]);					}				}				//find products that both users have rated				matches = setIntersection(set1, set2);				double score = 0.0;				int items = 0;				for(set<Product*>::iterator it = matches.begin(); it != matches.end(); ++it)				{					//see what rating the users gave the respective product					map<string, int> map1 = allusers[i]->getUserRevs();					map<string, int> map2 = allusers[j]->getUserRevs();					score += abs(double(map1[(*it)->getName()]) - double(map2[(*it)->getName()]))/4;					items++;				}				if(items != 0)				{					score = double(score/items);				}				//if the users have no rated products in comment				else				{					score = 1;				}				allsims[allusers[i]->getName()].push_back(make_pair(allusers[j]->getName(),score));			}		}	}}vector<pair<string,double>> myDataStore::refinedSims(string username){	Heap<string> h1;	h1.push(0.0, username);	vector<pair<string, double>> final = allsims[username];	//push all of the current user's neighbours into the vector	for (int i = 0; i < int(final.size());i++)	{		h1.push(final[i].second, final[i].first);	}	while(!h1.empty())	{		string top = h1.top();		h1.pop();		//loop through all neighbors of other users		for(int j = 0; j < int(allsims[top].size()); j++)		{			double u = allsims[top][j].second;			string name = allsims[top][j].first;			//store index of user in original user's similarities array			int idx = 0;			for(int n = 0; n < int(final.size()); n++)			{				if(final[n].first == name)				{					idx = n; 					break;				}			}			for(int k = 0; k < int(final.size()); k++)			{				if(final[k].first == top)				{					//check if same users since different user's vectors have different user orders					//if new distance found is less than original user's distance to neighbour					if(final[k].second + u < final[idx].second)					{						h1.decreaseKey(final[k].second + u, final[idx].first);						final[idx].second = final[k].second + u;					}				}			}		}	}	return final;}